# 排序算法
主要参考了《算法导论》，其中[sort.go](sorts.go)为测试代码

所有线性表元素个数都假定为n

## 选择排序(SelectionSort)

代码实现见[SelectionSort.go](sorts/SelectionSort.go)，参考《算法设计与分析基础》第3.1节

1. 从待排序线性表中根据两两比较找到最大的元素，把第一个元素与最小的元素做交换；
2. 因为第一个元素已经是最小元素，位置确定，所以从线性表的第二个元素开始找其中最小的元素(第二小元素)，再把第二个元素跟找到的最小元素交换；
3. 按照欧第1、2步骤的方法依次找到第m个最小元素跟第m个位置的元素进行交换，直到m=n-1

伪代码如下(使用数组实现)：

```
SelectionSort(A[0...n-1])
    //输入: 数组 A[0...n-1]，其中元素是可排序的(即：可比较的)
    //输出：非降序的数组，修改了原数组
    for i = 0 to n-2 do
        min = i
        for j = i+1 to n-1 do
            if A[j] < A[min] // 此处没有等号，所以程序是稳定的
                min = j
        A[i],A[min] = A[min],A[i]
```

从伪代码中可以看到，元素之间的比较为平方级效率 n<sup>2</sup>，而交换元素则是线性效率`n`

## 冒泡排序(BubbleSort)

代码实现见[BubbleSort.go](sorts/BubbleSort.go)，参考《算法设计与分析基础》第3.1节

1. 从第1个元素开始，与第2个元素进行比较，若大于第2个元素，则交换；若第2个元素比第3个元素大，则交换；一直到n-1和n；最大值交换到n的位置
2. 与第一步类似，从第1个元素到第n-1个元素；一直到从第1个元素到第2个元素截止

伪代码如下(使用数组实现)：

```
BubbleSort(A[0...n-1])
    for i = 0 to n-2 do
        for j = 0 to n-2-i do
            if A[j+1] < A[j]
                A[j+1],A[j] = A[j],A[j+1]
```

比较的效率为平方级 n<sup>2</sup>，交换元素的效率也是平方级 n<sup>2</sup>

## 插入排序(InsertionSort)

代码实现[InsertionSort.go](sorts/InsertionSort.go)，参考《算法设计与分析基础》第4.1节

与打扑克类比：
* 插入排序就像打扑克发牌时，把牌按照大小顺序一个一个的插入到手中。
* 手里没牌时，直接放到手中；
* 有一个牌时，先比较发到的牌与手中的牌的大小，若手中牌大，则插入左侧；若手中牌小，则插入右侧。
* 若手中牌较多时，则可能会按照大小顺序插入中间。

伪代码如下(使用数组实现)：

```
InsertionSort(A[0...n-1])
    for i = 1 to n-1 do
        v = A[i]
        j = i-1
        while j >= 0 && A[j] > v do
            A[j+1] = A[j] //位置小于i的元素已排好序，因此只需依次移位
            j = j-1
        A[j+1] = v
```

对于接近排好序的线性表，插入排序拥有很好的效率